## 시스템 콜 구현

### 1. 개요

* 시스템 콜을 관리해주는 시스템 콜 핸들러와 일부 시스템 콜(halt, exit, create, remove)을 구현하여, 응용 프로그램에서 시스템 콜을 호출할 수 있도록 한다.

### 2. 목표
* esp를 통해 유저스택을 읽어 시스템 콜 넘버를 받아오고, 해당 넘버에 알맞는 시스템 콜을 호출하도록 한다.
* 특정 주소값이 유저 스택에 위치하고 있지 않다면 프로세스를 강제 종료하는 `check_address()` 함수를 구현한다.
* esp를 통해 유저스택을 읽어 스택 내부 값들의 주소를 배열에 저장한다.

### 3. 과제 해결을 위한 Pintos 분석
* 유저 스택의 top에는 호출할 시스템 콜의 번호가 저장되며, 그 아래로 차례대로 해당 시스템 콜의 인자들이 저장된다. 편의상 top/아래로 표현했지만 실제로는 스택이 깊을 수록 높은 주소에 위치한다.
* esp의 조작이 필요한데, 인터럽트의 esp 변수는 void* 타입이다. C 표준에서는 원칙적으로 void 포인터 타입의 산술 연산이 금지(illegal)되어 있다. 하지만 Pintos 컴파일시 사용되는 GCC 확장에서는 그러한 연산이 허용되며, Pintos 코드 내에서도 이미 void 포인터의 산술 연산이 캐스팅 없이 사용되고 있음을 확인했으므로 여기서도 그냥 캐스팅을 하지 않고 void 포인터를 직접 조작하기로 했다.
* 시스템 콜 번호는 lib/syscall_nr.h에 enum으로 정의되어 있다.

### 4. 해결과정

#### 수정한 파일
* userprog/syscall.c
* userprog/syscall.h

#### 1) 유저 스택에 저장된 시스템 콜 인자 로드
* 유저 스택에 저장된 시스템 콜 인자들을 커널로 불러와야 하는데 이를 그대로 복사하여 값을 저장할 것인지, 유저 스택의 해당 주소값만을 저장할 것인지에 대한 고민이 있었다. 하지만 커널에서 직접 유저 스택의 값을 참조하면 문제가 생길 수 있으므로 안정성을 위해 약간의 오버헤드를 감수하고 값을 그대로 복사하였다.


## 프로세스 계층 구조
### 1. 개요
* 부모/자식 프로세스의 계층 구조를 구현하고, 세마포어를 통해 부모 프로세스가 자식 프로세스의 로드 및 종료 작업에서 대기할 수 있도록 한다.

### 2. 목표
### 3. 과제 해결을 위한 Pintos 분석
### 4. 해결 과정
#### 수정한 파일
* userprog/syscall.c
* userprog/syscall.h
* userprog/process.c
* userprog/process.h
* threads/thread.c
* threads/thread.h

### 5. 개선해야할 점
* 스레드와 프로세스가 일대일 관계(프로세스 하나 = 스레드 하나)처럼 되어 있음을 전제로 하여 많은 혼란을 준다. 예를들어 pid와 tid는 같은 값이지만 굳이 두 타입을 모두 사용한다. 또, process.c와 thread.c가 담당하는 코드가 명확히 분리되어 있지 않다. 리팩토링이 필요하다.

## 파일 디스크립터
### 1. 개요
* 파일 디스크립터 및 관련 시스템 콜이 누락되어 있어 파일 입출력이 불가능하므로 이를 구현한다.

### 2. 목표
* 요청된 파일을 열고 이를 thread 구조체의 file_desc 배열에 넣어 관리한다.
* 최대 갯수는 32개로 한다.
	* 리스트로 관리할 수 도 있으나 인덱스 속도를 위해 적정숫자로 사용
* syscall을 이용하여 커널모드에서 파일 입출력이 가능하도록 한다.

### 3. 과제 해결을 위한 Pintos 분석

* 위 과제에서 구현한 시스템콜을 구현과 같은 방식으로 filesys_*, file_* 함수들을 이용하여 구현한다.
* lock의 위치 struct file이 적합할것으로 판단된다.

### 4. 해결 과정

1. struct thread에 file descriptor를 관리할 배열을 생성한다.
2. init_thread에서 초기화한다. 단, 이 떄 초기갯수는 3임에 유의(standard IO)
3. 과제 명세(PDF)에 명시된 대로 필요한 시스템 콜들의 목록을 확인한다.
4. 해당 함수들을 구현하고 syscall handler에 등록한다.
5. 동작을 확인한다.

## 최종 결과

스크린샷